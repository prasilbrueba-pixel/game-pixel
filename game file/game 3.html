<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Escena RPG</title>
    <style>
        /* Estilos para centrar el juego y darle un aspecto agradable */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c2c2c;
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }
        canvas {
            background-color: #000;
            border: 4px solid #5a5a5a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        h1 {
            margin-bottom: 1rem;
        }
        p {
            margin-top: 1rem;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>

    <h1>Mi Escena RPG</h1>
    <canvas id="gameCanvas"></canvas>
    <p id="status-text">Cargando recursos del juego...</p>

    <script>
        /**
         * Datos de la escena RPG generados por el Creador de Escenas.
         * Estructura de carpetas recomendada:
         * ───/
         * ├── index.html  (Este archivo)
         * ├── assets/
         * │   ├── player/
         * │   │   └── (imágenes del jugador aquí)
         * │   ├── npc1/
         * │   │   └── (imágenes de npc1 aquí)
         * │   └── house.png
         */
        const sceneData = {
            background: 'assets/house.png',
            collisionGrid: [[1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,1,1,1,0,0,1,1,1,1]],
            characters: {
                player: {
                    sprites: {
                        'walk-up-1': 'assets/player/arriba 1.png',
                        'walk-up-2': 'assets/player/arriba 2.png',
                        'walk-down-1': 'assets/player/abajo 1.png',
                        'walk-down-2': 'assets/player/abajo 2.png',
                        'walk-left-1': 'assets/player/izquierda 1.png',
                        'walk-left-2': 'assets/player/izquierda 2.png',
                        'walk-right-1': 'assets/player/derecha 1.png',
                        'walk-right-2': 'assets/player/derecha 2.png',
                        'idle-up': 'assets/player/arriba 1.png',
                        'idle-down': 'assets/player/abajo 1.png',
                        'idle-left': 'assets/player/izquierda 1.png',
                        'idle-right': 'assets/player/derecha 2.png'
                    }
                },
                npc1: {
                    sprites: {
                        'walk-up-1': 'assets/npc1/arriba 1.png',
                        'walk-up-2': 'assets/npc1/arriba 2.png',
                        'walk-down-1': 'assets/npc1/abajo 1.png',
                        'walk-down-2': 'assets/npc1/abajo 2.png',
                        'walk-left-1': 'assets/npc1/izquierda 1.png',
                        'walk-left-2': 'assets/npc1/izquierda 2.png',
                        'walk-right-1': 'assets/npc1/derecha 1.png',
                        'walk-right-2': 'assets/npc1/derecha 2.png',
                        'idle-up': 'assets/npc1/arriba 1.png',
                        'idle-down': 'assets/npc1/abajo 1.png',
                        'idle-left': 'assets/npc1/izquierda 1.png',
                        'idle-right': 'assets/npc1/derecha 1.png'
                    }
                }
            }
        };

        // --- CONFIGURACIÓN DEL JUEGO ---
        const TILE_SIZE = 64; // Tamaño de cada celda en píxeles
        const PLAYER_SPEED = 3; // Velocidad de movimiento del jugador
        const NPC_SPEED = 1.5; // Velocidad de movimiento del NPC
        const ANIMATION_SPEED = 150; // Milisegundos por frame de animación

        // --- INICIALIZACIÓN DEL CANVAS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status-text');

        // --- Lógica para renderizado en alta definición (HiDPI/Retina) ---
        const dpr = window.devicePixelRatio || 1;
        const baseWidth = sceneData.collisionGrid[0].length * TILE_SIZE;
        const baseHeight = sceneData.collisionGrid.length * TILE_SIZE;
        canvas.width = baseWidth * dpr;
        canvas.height = baseHeight * dpr;
        canvas.style.width = `${baseWidth}px`;
        canvas.style.height = `${baseHeight}px`;
        ctx.imageSmoothingEnabled = false;

        // --- ESTADO DEL JUEGO ---
        const gameState = {
            assets: {},
            player: {
                x: TILE_SIZE * 2,
                y: TILE_SIZE * 2,
                direction: 'down',
                isMoving: false,
                animationFrame: 1,
                lastAnimationTime: 0
            },
            npc1: {
                x: TILE_SIZE * 6,
                y: TILE_SIZE * 4,
                direction: 'down',
                isMoving: false,
                animationFrame: 1,
                lastAnimationTime: 0,
                movementCooldown: 2000, // Tiempo a esperar para la próxima decisión
                lastMoveDecisionTime: 0, // Cuándo se tomó la última decisión
                moveUntil: 0 // Timestamp hasta el cual el NPC debe moverse
            },
            keys: {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false
            }
        };

        // --- CARGADOR DE RECURSOS ---
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.error(`Error al cargar la imagen: ${src}`);
                    const placeholder = new Image();
                    placeholder.src = `https://placehold.co/64x64/ff0000/ffffff?text=ERROR`;
                    placeholder.onload = () => resolve(placeholder);
                };
                img.src = src;
            });
        }

        async function loadAssets() {
            // Cargar fondo
            gameState.assets.background = await loadImage(sceneData.background);

            // Cargar sprites de personajes
            gameState.assets.characters = {};
            for (const charName in sceneData.characters) {
                gameState.assets.characters[charName] = {};
                for (const spriteName in sceneData.characters[charName].sprites) {
                    const path = sceneData.characters[charName].sprites[spriteName];
                    gameState.assets.characters[charName][spriteName] = await loadImage(path);
                }
            }
        }

        // --- MANEJO DE ENTRADA (TECLADO) ---
        window.addEventListener('keydown', (e) => {
            if (gameState.keys.hasOwnProperty(e.key)) {
                gameState.keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameState.keys.hasOwnProperty(e.key)) {
                gameState.keys[e.key] = false;
            }
        });

        // --- LÓGICA DE ACTUALIZACIÓN ---
        
        // Actualiza la lógica del jugador
        function updatePlayer(timestamp) {
            const { player, keys } = gameState;
            let moved = false;

            let nextX = player.x;
            let nextY = player.y;

            if (keys.ArrowUp) {
                player.direction = 'up';
                nextY -= PLAYER_SPEED;
                moved = true;
            } else if (keys.ArrowDown) {
                player.direction = 'down';
                nextY += PLAYER_SPEED;
                moved = true;
            } else if (keys.ArrowLeft) {
                player.direction = 'left';
                nextX -= PLAYER_SPEED;
                moved = true;
            } else if (keys.ArrowRight) {
                player.direction = 'right';
                nextX += PLAYER_SPEED;
                moved = true;
            }
            
            player.isMoving = moved;

            if (moved) {
                const playerBox = {
                    topLeft: { x: nextX, y: nextY + TILE_SIZE / 2 }, // Ajuste para colisión más realista
                    bottomRight: { x: nextX + TILE_SIZE - 1, y: nextY + TILE_SIZE - 1 }
                };
                
                const gridTopLeftX = Math.floor(playerBox.topLeft.x / TILE_SIZE);
                const gridTopLeftY = Math.floor(playerBox.topLeft.y / TILE_SIZE);
                const gridBottomRightX = Math.floor(playerBox.bottomRight.x / TILE_SIZE);
                const gridBottomRightY = Math.floor(playerBox.bottomRight.y / TILE_SIZE);

                if (
                    sceneData.collisionGrid[gridTopLeftY]?.[gridTopLeftX] !== 1 &&
                    sceneData.collisionGrid[gridTopLeftY]?.[gridBottomRightX] !== 1 &&
                    sceneData.collisionGrid[gridBottomRightY]?.[gridTopLeftX] !== 1 &&
                    sceneData.collisionGrid[gridBottomRightY]?.[gridBottomRightX] !== 1
                ) {
                    player.x = nextX;
                    player.y = nextY;
                }
            }

            if (player.isMoving) {
                if (timestamp - player.lastAnimationTime > ANIMATION_SPEED) {
                    player.animationFrame = player.animationFrame === 1 ? 2 : 1;
                    player.lastAnimationTime = timestamp;
                }
            } else {
                player.animationFrame = 1;
            }
        }

        // Actualiza la lógica del NPC con movimiento aleatorio
        function updateNpc(timestamp) {
            const npc = gameState.npc1;

            // Es hora de tomar una nueva decisión de movimiento
            if (timestamp > npc.lastMoveDecisionTime + npc.movementCooldown) {
                const willMove = Math.random() > 0.4; // 60% de probabilidad de moverse

                if (willMove) {
                    const directions = ['up', 'down', 'left', 'right'];
                    npc.direction = directions[Math.floor(Math.random() * directions.length)];
                    npc.isMoving = true;
                    // Moverse por una duración aleatoria (entre 0.5 y 1.5 segundos)
                    const moveDuration = 500 + Math.random() * 1000;
                    npc.moveUntil = timestamp + moveDuration;
                } else {
                    npc.isMoving = false;
                }
                
                // Reiniciar el temporizador de decisión
                npc.lastMoveDecisionTime = timestamp;
                npc.movementCooldown = 1000 + Math.random() * 3000; // Esperar entre 1 y 4 segundos para la próxima decisión
            }

            // Si el NPC está programado para moverse y la duración no ha expirado
            if (npc.isMoving && timestamp < npc.moveUntil) {
                let nextX = npc.x;
                let nextY = npc.y;

                if (npc.direction === 'up') nextY -= NPC_SPEED;
                else if (npc.direction === 'down') nextY += NPC_SPEED;
                else if (npc.direction === 'left') nextX -= NPC_SPEED;
                else if (npc.direction === 'right') nextX += NPC_SPEED;

                // Detección de colisiones para el NPC
                const npcBox = {
                    topLeft: { x: nextX, y: nextY + TILE_SIZE / 2 },
                    bottomRight: { x: nextX + TILE_SIZE - 1, y: nextY + TILE_SIZE - 1 }
                };
                const gridTopLeftX = Math.floor(npcBox.topLeft.x / TILE_SIZE);
                const gridTopLeftY = Math.floor(npcBox.topLeft.y / TILE_SIZE);
                const gridBottomRightX = Math.floor(npcBox.bottomRight.x / TILE_SIZE);
                const gridBottomRightY = Math.floor(npcBox.bottomRight.y / TILE_SIZE);

                if (
                    sceneData.collisionGrid[gridTopLeftY]?.[gridTopLeftX] !== 1 &&
                    sceneData.collisionGrid[gridTopLeftY]?.[gridBottomRightX] !== 1 &&
                    sceneData.collisionGrid[gridBottomRightY]?.[gridTopLeftX] !== 1 &&
                    sceneData.collisionGrid[gridBottomRightY]?.[gridBottomRightX] !== 1
                ) {
                    npc.x = nextX;
                    npc.y = nextY;
                } else {
                    // Si choca, para de moverse inmediatamente y fuerza una nueva decisión
                    npc.isMoving = false;
                    npc.moveUntil = 0;
                }

                // Animación del NPC
                if (timestamp - npc.lastAnimationTime > ANIMATION_SPEED) {
                    npc.animationFrame = npc.animationFrame === 1 ? 2 : 1;
                    npc.lastAnimationTime = timestamp;
                }
            } else {
                npc.isMoving = false;
            }

            if (!npc.isMoving) {
                npc.animationFrame = 1;
            }
        }

        function update(timestamp) {
            updatePlayer(timestamp);
            updateNpc(timestamp);
        }

        // --- LÓGICA DE DIBUJADO ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(dpr, dpr);

            if (gameState.assets.background) {
                ctx.drawImage(gameState.assets.background, 0, 0, baseWidth, baseHeight);
            }
            
            // Recolectar todos los personajes para ordenarlos por su posición 'y'
            const charactersToDraw = [gameState.player, gameState.npc1];
            charactersToDraw.sort((a, b) => a.y - b.y);

            // Dibujar cada personaje
            charactersToDraw.forEach((char, index) => {
                const isPlayer = index === charactersToDraw.indexOf(gameState.player);
                const charName = isPlayer ? 'player' : 'npc1';

                let spriteName = '';
                if (char.isMoving) {
                    spriteName = `walk-${char.direction}-${char.animationFrame}`;
                } else {
                    spriteName = `idle-${char.direction}`;
                }
                
                const sprite = gameState.assets.characters?.[charName]?.[spriteName];
                if (sprite) {
                    // Dibuja la sombra primero para dar profundidad
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(char.x + TILE_SIZE / 2, char.y + TILE_SIZE - 8, TILE_SIZE / 3, TILE_SIZE / 8, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.drawImage(sprite, char.x, char.y, TILE_SIZE, TILE_SIZE);
                }
            });

            ctx.restore();
        }

        // --- BUCLE PRINCIPAL DEL JUEGO ---
        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- INICIAR EL JUEGO ---
        async function main() {
            try {
                await loadAssets();
                statusText.textContent = '¡Listo! Usa las flechas del teclado para moverte.';
                requestAnimationFrame(gameLoop);
            } catch (error) {
                statusText.textContent = 'Error fatal al cargar los recursos. Revisa la consola (F12).';
                console.error("No se pudieron cargar los recursos:", error);
            }
        }

        main();

    </script>
</body>
</html>
