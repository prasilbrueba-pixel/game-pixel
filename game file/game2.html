<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Escena RPG</title>
    <style>
        /* Estilos para centrar el juego y darle un aspecto agradable */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c2c2c;
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }
        canvas {
            background-color: #000;
            border: 4px solid #5a5a5a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        h1 {
            margin-bottom: 1rem;
        }
        p {
            margin-top: 1rem;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>

    <h1>Mi Escena RPG</h1>
    <canvas id="gameCanvas"></canvas>
    <p id="status-text">Cargando recursos del juego...</p>

    <script>
        /**
         * Datos de la escena RPG generados por el Creador de Escenas.
         * Estructura de carpetas recomendada:
         * ───/
         * ├── index.html  (Este archivo)
         * ├── assets/
         * │   ├── player/
         * │   │   └── (imágenes del jugador aquí)
         * │   ├── npc1/
         * │   │   └── (imágenes de npc1 aquí)
         * │   └── house.png
         */
        const sceneData = {
            background: 'assets/house.png',
            collisionGrid: [[1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,1],[1,1,1,1,0,0,1,1,1,1]],
            characters: {
                player: {
                    sprites: {
                        'walk-up-1': 'assets/player/arriba 1.png',
                        'walk-up-2': 'assets/player/arriba 2.png',
                        'walk-down-1': 'assets/player/abajo 1.png',
                        'walk-down-2': 'assets/player/abajo 2.png',
                        'walk-left-1': 'assets/player/izquierda 1.png',
                        'walk-left-2': 'assets/player/izquierda 2.png',
                        'walk-right-1': 'assets/player/derecha 1.png',
                        'walk-right-2': 'assets/player/derecha 2.png',
                        'idle-up': 'assets/player/arriba 1.png',
                        'idle-down': 'assets/player/abajo 1.png',
                        'idle-left': 'assets/player/izquierda 1.png',
                        'idle-right': 'assets/player/derecha 2.png'
                    }
                },
                npc1: {
                    sprites: {
                        'walk-up-1': 'assets/npc1/arriba 1.png',
                        'walk-up-2': 'assets/npc1/arriba 2.png',
                        'walk-down-1': 'assets/npc1/abajo 1.png',
                        'walk-down-2': 'assets/npc1/abajo 2.png',
                        'walk-left-1': 'assets/npc1/izquierda 1.png',
                        'walk-left-2': 'assets/npc1/izquierda 2.png',
                        'walk-right-1': 'assets/npc1/derecha 1.png',
                        'walk-right-2': 'assets/npc1/derecha 2.png',
                        'idle-up': 'assets/npc1/arriba 1.png',
                        'idle-down': 'assets/npc1/abajo 1.png',
                        'idle-left': 'assets/npc1/izquierda 1.png',
                        'idle-right': 'assets/npc1/derecha 1.png'
                    }
                }
            }
        };

        // --- CONFIGURACIÓN DEL JUEGO ---
        const TILE_SIZE = 64; // Tamaño de cada celda en píxeles
        const PLAYER_SPEED = 3; // Velocidad de movimiento del jugador
        const ANIMATION_SPEED = 150; // Milisegundos por frame de animación

        // --- INICIALIZACIÓN DEL CANVAS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status-text');

        // --- Lógica para renderizado en alta definición (HiDPI/Retina) ---
        // 1. Obtenemos la relación de píxeles del dispositivo (ej. 1 para pantallas estándar, 2 para Retina).
        const dpr = window.devicePixelRatio || 1;

        // 2. Calculamos el tamaño base que queremos que el juego ocupe en la pantalla.
        const baseWidth = sceneData.collisionGrid[0].length * TILE_SIZE;
        const baseHeight = sceneData.collisionGrid.length * TILE_SIZE;

        // 3. Aumentamos la resolución REAL del canvas multiplicándola por la densidad de píxeles.
        // El canvas ahora tiene más píxeles internos para dibujar.
        canvas.width = baseWidth * dpr;
        canvas.height = baseHeight * dpr;

        // 4. Usamos CSS para que el canvas se muestre en el tamaño base.
        // El navegador ahora comprimirá el canvas de alta resolución en un espacio más pequeño, creando una imagen nítida.
        canvas.style.width = `${baseWidth}px`;
        canvas.style.height = `${baseHeight}px`;
        
        // 5. Desactivamos el suavizado de imágenes, que sigue siendo importante para el estilo pixel art.
        ctx.imageSmoothingEnabled = false;

        // --- ESTADO DEL Juego ---
        const gameState = {
            assets: {},
            player: {
                x: TILE_SIZE * 2,
                y: TILE_SIZE * 2,
                direction: 'down',
                isMoving: false,
                animationFrame: 1,
                lastAnimationTime: 0
            },
            npc1: {
                x: TILE_SIZE * 6,
                y: TILE_SIZE * 4,
                direction: 'down',
                isMoving: false,
                animationFrame: 1
            },
            keys: {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false
            }
        };

        // --- CARGADOR DE RECURSOS ---
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                // Si la imagen no se carga, muestra un placeholder para que sepas qué archivo falta
                img.onerror = () => {
                    console.error(`Error al cargar la imagen: ${src}`);
                    const placeholder = new Image();
                    placeholder.src = `https://placehold.co/64x64/ff0000/ffffff?text=ERROR`;
                    placeholder.onload = () => resolve(placeholder);
                };
                img.src = src;
            });
        }

        async function loadAssets() {
            // Cargar fondo
            gameState.assets.background = await loadImage(sceneData.background);

            // Cargar sprites de personajes
            gameState.assets.characters = {};
            for (const charName in sceneData.characters) {
                gameState.assets.characters[charName] = {};
                for (const spriteName in sceneData.characters[charName].sprites) {
                    const path = sceneData.characters[charName].sprites[spriteName];
                    gameState.assets.characters[charName][spriteName] = await loadImage(path);
                }
            }
        }

        // --- MANEJO DE ENTRADA (TECLADO) ---
        window.addEventListener('keydown', (e) => {
            if (gameState.keys.hasOwnProperty(e.key)) {
                gameState.keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameState.keys.hasOwnProperty(e.key)) {
                gameState.keys[e.key] = false;
            }
        });

        // --- LÓGICA DE ACTUALIZACIÓN ---
        function update(timestamp) {
            const { player, keys } = gameState;
            let moved = false;

            // Calcular nueva posición
            let nextX = player.x;
            let nextY = player.y;

            if (keys.ArrowUp) {
                player.direction = 'up';
                nextY -= PLAYER_SPEED;
                moved = true;
            } else if (keys.ArrowDown) {
                player.direction = 'down';
                nextY += PLAYER_SPEED;
                moved = true;
            } else if (keys.ArrowLeft) {
                player.direction = 'left';
                nextX -= PLAYER_SPEED;
                moved = true;
            } else if (keys.ArrowRight) {
                player.direction = 'right';
                nextX += PLAYER_SPEED;
                moved = true;
            }
            
            player.isMoving = moved;

            // Detección de colisiones
            if (moved) {
                // Comprobamos la esquina superior izquierda y la inferior derecha del jugador
                const playerBox = {
                    topLeft: { x: nextX, y: nextY },
                    bottomRight: { x: nextX + TILE_SIZE -1, y: nextY + TILE_SIZE - 1 }
                };
                
                const gridTopLeftX = Math.floor(playerBox.topLeft.x / TILE_SIZE);
                const gridTopLeftY = Math.floor(playerBox.topLeft.y / TILE_SIZE);
                const gridBottomRightX = Math.floor(playerBox.bottomRight.x / TILE_SIZE);
                const gridBottomRightY = Math.floor(playerBox.bottomRight.y / TILE_SIZE);

                // Verificamos si alguna de las esquinas del personaje colisionaría
                if (
                    sceneData.collisionGrid[gridTopLeftY]?.[gridTopLeftX] !== 1 &&
                    sceneData.collisionGrid[gridTopLeftY]?.[gridBottomRightX] !== 1 &&
                    sceneData.collisionGrid[gridBottomRightY]?.[gridTopLeftX] !== 1 &&
                    sceneData.collisionGrid[gridBottomRightY]?.[gridBottomRightX] !== 1
                ) {
                    player.x = nextX;
                    player.y = nextY;
                }
            }

            // Actualizar frame de animación
            if (player.isMoving) {
                if (timestamp - player.lastAnimationTime > ANIMATION_SPEED) {
                    player.animationFrame = player.animationFrame === 1 ? 2 : 1;
                    player.lastAnimationTime = timestamp;
                }
            } else {
                player.animationFrame = 1; // Frame por defecto cuando está quieto
            }
        }

        // --- LÓGICA DE DIBUJADO ---
        function draw() {
            // Limpiamos el canvas usando su tamaño real de alta resolución.
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Guardamos el estado del contexto.
            ctx.save();
            
            // Escalamos todo el sistema de coordenadas. Ahora, cuando pidamos dibujar algo
            // en la posición (x, y), se dibujará en (x*dpr, y*dpr), llenando el canvas grande.
            ctx.scale(dpr, dpr);

            // Dibujar el fondo. Usamos las dimensiones base, ya que la escala se encarga del resto.
            if (gameState.assets.background) {
                ctx.drawImage(gameState.assets.background, 0, 0, baseWidth, baseHeight);
            }

            // Dibujar NPC
            const npc = gameState.npc1;
            const npcSpriteName = `idle-${npc.direction}`;
            const npcSprite = gameState.assets.characters?.npc1?.[npcSpriteName];
            if (npcSprite) {
                ctx.drawImage(npcSprite, npc.x, npc.y, TILE_SIZE, TILE_SIZE);
            }

            // Dibujar jugador
            const player = gameState.player;
            let playerSpriteName = '';
            if (player.isMoving) {
                playerSpriteName = `walk-${player.direction}-${player.animationFrame}`;
            } else {
                // Seleccionamos un sprite 'idle' apropiado según la dirección
                if (player.direction === 'up') playerSpriteName = 'idle-up';
                else if (player.direction === 'left') playerSpriteName = 'idle-left';
                else if (player.direction === 'right') playerSpriteName = 'idle-right';
                else playerSpriteName = 'idle-down';
            }
            
            const playerSprite = gameState.assets.characters?.player?.[playerSpriteName];
            if (playerSprite) {
                ctx.drawImage(playerSprite, player.x, player.y, TILE_SIZE, TILE_SIZE);
            }

            // Restauramos el contexto para que la escala no se acumule en el siguiente frame.
            ctx.restore();
        }

        // --- BUCLE PRINCIPAL DEL JUEGO ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- INICIAR EL JUEGO ---
        async function main() {
            try {
                await loadAssets();
                statusText.textContent = '¡Listo! Usa las flechas del teclado para moverte.';
                requestAnimationFrame(gameLoop); // Inicia el bucle del juego
            } catch (error) {
                statusText.textContent = 'Error fatal al cargar los recursos. Revisa la consola (F12).';
                console.error("No se pudieron cargar los recursos:", error);
            }
        }

        main();

    </script>
</body>
</html>


